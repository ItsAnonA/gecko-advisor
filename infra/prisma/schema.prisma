// SPDX-FileCopyrightText: 2025 Gecko Advisor contributors
// SPDX-License-Identifier: MIT

generator client {
  provider      = "prisma-client-js"
  output        = "../../node_modules/.prisma/client"
  binaryTargets = ["native", "debian-openssl-3.0.x", "linux-arm64-openssl-3.0.x"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// Existing enums
enum IssueSeverity {
  info
  low
  medium
  high
  critical
}

enum CheckFrequency {
  DAILY
  WEEKLY
  MONTHLY
}

// Simplified User model - authentication removed
model User {
  id    String  @id @default(cuid())
  email String  @unique
  name  String?

  // Relations
  watchedUrls WatchedUrl[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([email])
}

// Enhanced Scan model with user relations and privacy controls
model Scan {
  id              String    @id @default(cuid())
  targetType      String
  input           String
  normalizedInput String?
  status          String
  score           Int?
  label           String?
  progress        Int @default(0)
  summary         String?
  startedAt       DateTime?
  finishedAt      DateTime?
  slug            String    @unique
  source          String    @default("manual")
  dedupeOfId      String?
  shareMessage    String?
  meta            Json?

  // Public access and rate limiting
  isPublic  Boolean @default(true)
  scannerIp String? // Track scans for rate limiting

  evidence  Evidence[]
  issues    Issue[]
  createdAt DateTime   @default(now())
  updatedAt DateTime   @default(now()) @updatedAt

  dedupeOf     Scan?  @relation("ScanDedupe", fields: [dedupeOfId], references: [id])
  dedupedScans Scan[] @relation("ScanDedupe")

  // Optimized indexes for critical performance paths
  @@index([normalizedInput, status, finishedAt(sort: Desc)], map: "Scan_dedupe_lookup_idx")
  @@index([status, createdAt(sort: Desc)], map: "Scan_recent_reports_idx")
  @@index([isPublic, createdAt(sort: Desc)], map: "Scan_public_reports_idx")
  @@index([scannerIp, createdAt(sort: Desc)], map: "Scan_ip_ratelimit_idx")
}

model Evidence {
  id        String   @id @default(cuid())
  scanId    String
  kind      String
  severity  Int
  title     String
  details   Json
  createdAt DateTime @default(now())
  scan      Scan     @relation(fields: [scanId], references: [id], onDelete: Cascade)

  // Covering index for optimal evidence queries and counting
  @@index([scanId, createdAt], map: "Evidence_scan_covering_idx")
}

model Issue {
  id           String        @id @default(cuid())
  scanId       String
  key          String?
  severity     IssueSeverity
  category     String
  title        String
  summary      String?
  howToFix     String?
  whyItMatters String?
  references   Json?
  sortWeight   Int?          @default(0)
  createdAt    DateTime      @default(now())
  updatedAt    DateTime      @default(now()) @updatedAt
  scan         Scan          @relation(fields: [scanId], references: [id], onDelete: Cascade)

  // Covering index for optimal issue queries with proper sorting
  @@index([scanId, sortWeight, createdAt], map: "Issue_scan_covering_idx")
  @@index([severity, sortWeight], map: "Issue_severity_idx")
}

model CachedList {
  id        String   @id @default(cuid())
  source    String
  version   String
  fetchedAt DateTime @default(now())
  data      Json
}

// Rate limiting for anonymous and free tier users
model RateLimit {
  id         String   @id @default(cuid())
  identifier String // IP address or user ID
  scansCount Int      @default(0)
  date       String // YYYY-MM-DD format for daily tracking
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  @@unique([identifier, date])
  @@index([identifier, date], map: "RateLimit_lookup_idx")
}

// Watched URLs for Pro users (monitoring and alerts)
model WatchedUrl {
  id             String         @id @default(cuid())
  userId         String
  user           User           @relation(fields: [userId], references: [id], onDelete: Cascade)
  url            String
  lastScore      Int?
  lastChecked    DateTime?
  checkFrequency CheckFrequency @default(WEEKLY)
  alertOnChange  Boolean        @default(true)
  createdAt      DateTime       @default(now())

  @@unique([userId, url])
  @@index([lastChecked, checkFrequency], map: "WatchedUrl_schedule_idx")
}
